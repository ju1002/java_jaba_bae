package com.kh.chap05.model.vo;
//모든 장르들에 play라는 메소드를 구현 시키기 위해 인터페이스를 만듬
/*인터페이스(interface)
 *  객체생성이 안된다.
 * [표현법]
 * 접근제한자 interface 인터페이스식별자{}
 * 
 * 
 * 
 * 
 * 구체클래스 :  
 * 추상클래스 : 
 * 인터페이스 :
 * 인터페이스의 특징
 *  추상클래스보다 더욱 강한 규칙성 , 강제성을 가짐
 * 인터페이스의 메소드 키워드를 붙이지 않는 이상 추상메소드
 * 인터페이스는 다중 구현을 허용한다.
 * 무조선 구현해야하는 기능이 있을 경우 인터페이스를 사용해서
 * 사용법만 만들어주고 구현하는 쪽에서 실체화하게 만듬 >> 오버라이딩 해서
 * 
 * 추상클래스와 인터페이스의 공통점
 * 객체생성은 불가능하지만 , 부모자료형의 참조타입으로는 사용이 가능함(다형성을 적용할 수 있음)
 * 추상메소드를 가지곳 있을 경우, 상속(구현)받는 클래스에서 추상메소드를 오버라이딩 하도록 강제함
 * 
 * 차이점
 * 추상클래스 : 멤버로 일반필드, 일반메소드를 가질 수있음
 * 			추상메소드는 있어도 그만 없어도 그만
 * 인터페이스 : 상수 필드, 특정한 경우를 제외 하면 모든 메소드를 추상메소드로 정의 해야함
 * 
 * 둘다 다형성을 적용하여 외부에서 보여지는 타입의 용도는 같지만ㅁ
 * 목저이 다름
 * 추상클래스는 자식클래스가 상속을 받아서 필드/메소드를 재사용하고 클래스를 확장하는용도
 * 인텨페이스는 기능의 구현을 강제하기 위한 용도 이유는 다중 메소드를 구현할 수 있기 때문이다.
 * 
 * 
 * 
 * 
 */
public interface MusicI {
	
	public static final int NUM = 1;
//인터페이스의 모든 필드들은 암묵적으로 public static final
//상수필드.
//인터페이스는 void 메소드명으로 메소드 부를 표현한다.
//public abstract가 void 앞에 생략이 된다. == 추상메소드다.
	void play();
	default void stop() { 
		System.out.println("음악을 멈춥니다.");
	}
	//인터페이스를 구현한 모든 클래스가 동일하게 수행해야 하는 메소드에는 default키워드를 붙임
	

}
